
BytecodeParser < BasicObject {
  var grammar: Grammar { }
  
  new_worker: set_up_worker(prototype.new)
  
  var prototype: compile_prototype
  
  refresh: self.prototype = compile_prototype
  
  compile_prototype: {
    proto = Component.new
    grammar.construct_all_rules
    grammar.rule_table.each |name, rule| {
      compile_rule_into(proto, name, rule)
    }
    proto
  }
  
  compile_rule_into: |proto, name, rule| {
    construct = rule.construct_rule
    
    proto.dynamic_method(name, "(compiled parser)") |g| {
      instructor = BytecodeInstructions { }
      instructor.g = g
      g.extend(BytecodeHelpers)
      
      g.rule_start
      construct.bytecode(instructor)
      g.rule_finish
    }
  }
  
  set_up_worker: |worker|
    worker.instance_variable_set(:"@captures", []); worker
  
  captures_of_worker: |worker|
    worker.instance_variable_get(:"@captures")
  
  new_processor: Processor.new(builder: new_builder)
  new_builder: Builder.new
  
  # Match and process the given string using the current grammar
  parse: |string| {
    worker = new_worker
    
    self.end_idx = worker.root(string, 0)
    
    capture_tokens = captures_of_worker(worker)
    
    self.result = end_idx
    if(end_idx) {
      processor = new_processor
      processor.string = string
      processor.capture_tokens = capture_tokens
      self.result = processor.process
    }
  }
  
  var end_idx
  var result
}
