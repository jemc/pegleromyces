
BytecodeParser < BasicObject {
  var grammar: Grammar { }
  
  new_worker: set_up_worker(prototype.new)
  
  var prototype: compile_prototype
  
  refresh: self.prototype = compile_prototype
  
  compile_prototype: {
    proto = Component.new
    grammar.construct_all_rules
    grammar.rule_table.each |name, rule| {
      compile_rule_into(proto, name, rule)
    }
    proto
  }
  
  compile_rule_into: |proto, name, rule| {
    construct = rule.construct_rule
    
    proto.dynamic_method(name, "(compiled parser)") |g| {
      instructor = BytecodeInstructions { }
      instructor.g = g
      g.extend(BytecodeHelpers)
      
      g.rule_start
      construct.bytecode(instructor)
      g.rule_finish
    }
  }
  
  compile_generator: |name, file, line=1, &block| {
    g = Myco::ToolSet::Generator.new
    g.name = name
    g.file = file
    g.set_line(line)
    
    block.call(g)
    
    g.ret
    g.close
    g.use_detected
    g
  }
  
  compile_code: |name, file, line=1, &block| {
    g = compile_generator(name, file, line, &block)
    g.encode
    g.package(Rubinius::CompiledCode)
  }
  
  save_prototype: |filename| {
    code = compile_code(:__script__, :"(snippet)") |g| {
      g.push_cpath_top; g.find_const(:"Class")
      g.create_block(compile_generator(:__block__, :"(snippet)") |g| {
        prototype.instance_methods.each |name| {
          g.push_rubinius
          g.push_literal(name)
          g.push_literal(prototype.instance_method(name).executable)
          g.push_scope
          g.push_variables
          g.send(:method_visibility, 0)
          g.send(:add_defn_method, 4)
        }
      })
      g.send_with_block(:new, 0)
    }
    
    Myco::ToolSet::CompiledFile.dump(code, filename, Rubinius::Signature, Rubinius::RUBY_LIB_VERSION)
  }
  
  load_prototype: |filename| {
    loader = Myco::CodeLoader::BytecodeLoader.new(filename)
    loader.bind_to(call_depth:1)
    self.prototype = loader.load
  }
  
  set_up_worker: |worker| {
    worker.instance_variable_set(:"@captures", [])
    worker.instance_variable_set(:"@highest_idx", 0)
    worker
  }
  
  captures_of_worker: |worker|
    worker.instance_variable_get(:"@captures")
  
  highest_idx_of_worker: |worker|
    worker.instance_variable_get(:"@highest_idx")
  
  new_processor: Processor.new(builder: new_builder)
  new_builder: Builder.new
  
  
  # Match and process the given string using the current grammar
  parse: |string| {
    worker = new_worker
    
    self.error_idx = null
    self.error_row = null
    self.error_col = null
    self.error_string = null
    self.result = null
    self.end_idx = worker.root(string, 0)
    
    processor = new_processor
    
    if(end_idx) {
      processor.string = string
      processor.capture_items = captures_of_worker(worker)
      self.result = processor.process
    }
    if(!end_idx) {
      self.error_idx = highest_idx_of_worker(worker)
      pos = processor.position_of(error_idx, string)
      self.error_row = pos.first
      self.error_col = pos.last
      self.error_string = \
      "Unexpected character near line: "error_row", column: "error_col".\n" \
        string.each_line.to_a[error_row - 1]"" \
        (' ' * [(error_col - 1), 0].max)"^"
    }
    self.result
  }
  
  var end_idx
  var result
  
  var error_idx
  var error_row
  var error_col
  var error_string
  raise_error: raise(SyntaxError, error_string)
}
