
Constructions < EmptyObject {
  
  ##
  # Basic types of constructions.
  
  Base < BasicObject { }
  UnaryBase  < Base { var inner }
  BinaryBase < Base { var first, var second }
  
  AnyCharacter      < Base { }
  Character         < Base { var code }
  CharacterString   < Base { var codes }
  CharacterSet      < Base { var codes }
  CharacterRange    < Base { var start, var stop }
  
  NegativePredicate < UnaryBase { }
  PositivePredicate < UnaryBase { }
  OneOrMore         < UnaryBase { }
  ZeroOrOne         < UnaryBase { }
  ZeroOrMore        < UnaryBase { }
  OrderedChoice     < BinaryBase { }
  Concatenation     < BinaryBase { }
  
  NamedCapture      < UnaryBase { var captor }
  Reduction         < UnaryBase { var captor }
  
  ##
  # Bindings of patterns to constructions.
  
  Patterns::UnaryBase << {
    construct: construct_type.new(inner:inner.construct)
  }
  
  Patterns::BinaryBase << {
    construct: construct_type.new(first:first.construct,second:second.construct)
  }
  
  Patterns::AnyCharacter      << { construct: AnyCharacter.new }
  Patterns::Character         << { construct: Character      .new(code:code) }
  Patterns::CharacterString   << { construct: CharacterString.new(codes:codes) }
  Patterns::CharacterSet      << { construct: CharacterSet   .new(codes:codes) }
  Patterns::CharacterRange    << { construct: CharacterRange .new(start:start
                                                                   stop:stop) }
  
  Patterns::NegativePredicate << { construct_type: NegativePredicate }
  Patterns::PositivePredicate << { construct_type: PositivePredicate }
  Patterns::OneOrMore         << { construct_type: OneOrMore }
  Patterns::ZeroOrOne         << { construct_type: ZeroOrOne }
  Patterns::ZeroOrMore        << { construct_type: ZeroOrMore }
  Patterns::OrderedChoice     << { construct_type: OrderedChoice }
  Patterns::Concatenation     << { construct_type: Concatenation }
  
  Patterns::NamedCapture      << {
    construct: NamedCapture.new(inner:inner.construct, captor:self.name)
  }
  Patterns::Reduction         << {
    construct: Reduction.new(inner:inner.construct, captor:self.code)
  }
  
  ##
  # The instruction sequence generator for each construction.
  
  AnyCharacter    << { sequence: [[:any, 1]] }
  Character       << { sequence: [[:char, code]] }
  CharacterString << { sequence: codes.map |code| { [:char, code] } }
  CharacterSet    << { sequence: [[:charset, table]]
                          table: codes.map |code| { [code, true] }.to_h }
  CharacterRange  << { sequence: [[:charrange, start, stop]] }
  
  NegativePredicate << {
    sequence: {
      a = inner.sequence
      [[:choice, a.size+2], *a, [:fail_twice]]
    }
  }
  
  PositivePredicate << {
    sequence: {
      a = inner.sequence
      size = a.size
      [[:choice, size+4], [:choice, size+1], *a, [:commit, 1], [:fail]]
    }
  }
  
  OneOrMore << {
    var inlaid
    sequence: {
      one = inner.sequence
      inlaid && (one = one + inlaid)
      or_more = ZeroOrMore.new(inner:inner,inlaid:inlaid).sequence
      [*one, *or_more]
    }
  }
  
  ZeroOrOne << {
    sequence: {
      a = inner.sequence
      [[:choice, a.size+2], *a, [:commit, 1]]
    }
  }
  
  ZeroOrMore << {
    var inlaid
    sequence:
      switch(inner, :"is_a?")
        .when(CharacterSet) { [[:span, inner.table]] }
        .else {
          a = inner.sequence
          inlaid && (a = a + inlaid)
          size = a.size
          [[:choice, size+2], *a, [:partial_commit, size*-1]]
        }
        .output
  }
  
  OrderedChoice << {
    sequence: {
      a = first.sequence
      b = second.sequence
      [[:choice, a.size+2], *a, [:commit, b.size+1], *b]
    }
  }
  
  Concatenation << {
    sequence: [*first.sequence, *second.sequence]
  }
  
  NamedCapture << {
    sequence: {
      (inner.is_a?(OneOrMore) || inner.is_a?(ZeroOrMore))
      && (
        inner.inlaid = [[:capture, [:m_split, captor]]]
        a = inner.sequence
        [[:capture, [:m_start, captor]], *a, [:capture, [:m_end, captor]]]
      ) || (
        a = inner.sequence
        [[:capture, [:c_start, captor]], *a, [:capture, [:c_end, captor]]]
      )
    }
  }
  
  Reduction << {
    sequence: {
      a = inner.sequence
      [[:capture, [:r_start, captor]], *a, [:capture, [:r_end, captor]]]
    }
  }
  
}
