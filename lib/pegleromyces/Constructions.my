
Constructions < EmptyObject {
  
  ##
  # Basic types of constructions.
  
  Base < BasicObject { }
  UnaryBase  < Base { var inner }
  BinaryBase < Base { var first, var second }
  
  AnyCharacter      < Base { }
  Character         < Base { var code }
  CharacterString   < Base { var codes }
  CharacterSet      < Base { var codes }
  CharacterRange    < Base { var start, var end }
  
  NegativePredicate < UnaryBase { }
  PositivePredicate < UnaryBase { }
  OneOrMore         < UnaryBase { }
  ZeroOrOne         < UnaryBase { }
  ZeroOrMore        < UnaryBase { }
  OrderedChoice     < BinaryBase { }
  Concatenation     < BinaryBase { }
  
  Capture           < UnaryBase { var captor }
  Composition       < UnaryBase { var captor }
  
  ##
  # Bindings of patterns to constructions.
  
  Patterns::UnaryBase << {
    construct: construct_type.new(inner:inner.construct)
  }
  
  Patterns::BinaryBase << {
    construct: construct_type.new(first:first.construct,second:second.construct)
  }
  
  Patterns::AnyCharacter      << { construct: AnyCharacter.new }
  Patterns::Character         << { construct: Character      .new(code:code) }
  Patterns::CharacterString   << { construct: CharacterString.new(codes:codes) }
  Patterns::CharacterSet      << { construct: CharacterSet   .new(codes:codes) }
  Patterns::CharacterRange    << { construct: CharacterRange .new(start:start
                                                                    end:end) }
  
  Patterns::NegativePredicate << { construct_type: NegativePredicate }
  Patterns::PositivePredicate << { construct_type: PositivePredicate }
  Patterns::OneOrMore         << { construct_type: OneOrMore }
  Patterns::ZeroOrOne         << { construct_type: ZeroOrOne }
  Patterns::ZeroOrMore        << { construct_type: ZeroOrMore }
  Patterns::OrderedChoice     << { construct_type: OrderedChoice }
  Patterns::Concatenation     << { construct_type: Concatenation }
  
  Patterns::Capture           << {
    construct: Capture.new(inner:inner.construct, captor:self)
  }
  Patterns::Composition       << {
    construct: Composition.new(inner:inner.construct, captor:self)
  }
  
  ##
  # The instruction sequence generator for each construction.
  
  AnyCharacter    << { sequence: [[:any, 1]] }
  Character       << { sequence: [[:char, code]] }
  CharacterString << { sequence: codes.map |code| { [:char, code] } }
  CharacterSet    << { sequence: [[:charset, table]]
                          table: codes.map |code| { [code, true] }.to_h }
  CharacterRange  << { sequence: [[:charrange, start, end]] }
  
  NegativePredicate << {
    sequence: {
      a = inner.sequence
      [[:choice, a.size+2], *a, [:fail_twice]]
    }
  }
  
  PositivePredicate << {
    sequence: {
      a = inner.sequence
      size = a.size
      [[:choice, size+4], [:choice, size+1], *a, [:commit, 1], [:fail]]
    }
  }
  
  OneOrMore << {
    sequence: {
      one = inner.sequence
      or_more = ZeroOrMore.new(inner:inner).sequence
      [*one, *or_more]
    }
  }
  
  ZeroOrOne << {
    sequence: {
      a = inner.sequence
      [[:choice, a.size+2], *a, [:commit, 1]]
    }
  }
  
  ZeroOrMore << {
    sequence:
      switch(inner, :"is_a?")
        .when(CharacterSet) { [[:span, inner.table]] }
        .else {
          a = inner.sequence
          size = a.size
          [[:choice, size+2], *a, [:partial_commit, size*-1]]
        }
        .output
  }
  
  OrderedChoice << {
    sequence: {
      a = first.sequence
      b = second.sequence
      [[:choice, a.size+2], *a, [:commit, b.size+1], *b]
    }
  }
  
  Concatenation << {
    sequence: [*first.sequence, *second.sequence]
  }
  
  Capture << {
    sequence: {
      a = inner.sequence
      [[:capture, [:start, captor]], *a, [:capture, [:end, captor]]]
    }
  }
  
  Composition << {
    sequence: {
      a = inner.sequence
      [[:capture, [:comp_start, captor]], *a, [:capture, [:comp_end, captor]]]
    }
  }
  
}
