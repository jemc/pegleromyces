##
# The following code is based on code from Pegarus by Brian Shirai.
# A link to the code in question and the relevant license is reproduced below.
# 
# https://github.com/brixen/pegarus/blob/master/lib/pegarus/rubinius/compiler.rb
# 
# Copyright (c) 2014, Brian Shirai
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. Neither the name of the library nor the names of its contributors may be
#    used to endorse or promote products derived from this software without
#    specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import "BytecodeHelpers.my"


# This set of instructions is not directly related to those in Instructions, as
# those are not necessarily suitable for direct translation to the Rubinius VM.
#
BytecodeInstructions < BasicObject {
  
  Constructions << {
    AnyCharacter    << { bytecode: |m| m.any(1) }
    Character       << { bytecode: |m| m.char(code.chr) }
    CharacterString << { bytecode: |m| m.char(codes.map(&:chr).join) }
    CharacterSet    << { bytecode: |m| m.set(codes.map(&:chr).join) }
    CharacterRange  << { bytecode: |m|
      codes = Range.new(start,stop); m.set(codes.map(&:chr).join)
    }
    
    NegativePredicate << { bytecode: |m|
      m.neg_predicate(Proc.new { inner.bytecode(m) })
    }
    PositivePredicate << { bytecode: |m|
      m.pos_predicate(Proc.new { inner.bytecode(m) })
    }
    OneOrMore << { bytecode: |m|
      m.many(Proc.new { inner.bytecode(m); inlaid.?call })
    }
    ZeroOrOne << {
      bytecode: |m| {
        m.choice(
          Proc.new { inner.bytecode(m) }
          Proc.new { }
        )
      }
    }
    ZeroOrMore << { bytecode: |m|
      m.kleene(Proc.new { inner.bytecode(m); inlaid.?call })
    }
    OrderedChoice << {
      bytecode: |m| {
        m.choice(
          Proc.new { first.bytecode(m) }
          Proc.new { second.bytecode(m) }
        )
      }
    }
    Concatenation << { bytecode: |m|
      first.bytecode(m); second.bytecode(m)
    }
    
    NamedCapture << {
      bytecode: |m| {
        (inner.is_a?(OneOrMore) || inner.is_a?(ZeroOrMore))
        && (
          inner.inlaid = Proc.new { m.capture(:m_split, captor) }
          m.capture(:m_start, captor)
          inner.bytecode(m)
          m.capture(:m_end, captor)
        ) || (
          m.capture(:c_start, captor)
          inner.bytecode(m)
          m.capture(:c_end, captor)
        )
      }
    }
    
    Reduction << {
      bytecode: |m| {
        m.capture(:r_start, captor)
        inner.bytecode(m)
        m.capture(:r_end, captor)
      }
    }
    
  }
  
  
  var g # The generator to use
  
  # Match any character, |count| number of times.
  any: |count| {
    g.push_idx
    g.push_int(count)
    g.send(:"+", 1)
    
    g.push_subject
    g.send(:size, 0)
    g.send(:"<=", 1)
    g.goto_if_false(g.overall_fail)
    
    g.push_int(count)
    g.increment_idx
  }
  
  # Match the given |string| of characters, one time.
  char: |string| {
    local_fail = g.new_label
    local_done = g.new_label
    
    g.push_literal(string)
    g.dup
    g.send(:size, 0)
    g.dup
    g.move_down(2)
    
    g.push_subject
    g.swap
    g.push_idx
    g.swap
    g.send(:substring, 2)
    g.send(:"==", 1)
    g.goto_if_false(local_fail)
    
    g.increment_idx
    g.goto(local_done)
    
    local_fail.set!
    g.pop
    g.goto(g.overall_fail)
    
    local_done.set!
  }
  
  # Match if the character is included in the given |string|, one time.
  set: |string| {
    local_done = g.new_label
    local_early_fail = g.new_label
    
    g.push_literal(string)
      g.push_subject_at_idx
      g.dup_top
      g.goto_if_false(local_early_fail)
      g.meta_push_0
    g.send(:find_string, 2)
    g.goto_if_false(g.overall_fail)
    g.goto(local_done)
    
    local_early_fail.set!
    g.pop # pop literal string
    g.pop # pop subject_at_idx
    g.goto(g.overall_fail)
    
    local_done.set!
    g.meta_push_1
    g.increment_idx
  }
  
  # An ordered choice between |first| and |second|.
  # Each argument should be a Proc that generates bytecode when called.
  choice: |first, second| {
    local_done = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    # Store index and captures for backtracking in case of failure
    g.push_temp_captures
    g.push_idx
    
    first.call
    
    # Success, throw away backtrack entry
    g.pop # keep idx
    g.pop_to_accept_captures
    g.overall_fail = old_fail # reset fail
    g.goto(local_done)
    
    # Failure, backtrack index and captures
    local_fail.set!
    g.pop_to_set_idx
    g.pop_to_reject_captures
    g.overall_fail = old_fail
    
    second.call
    
    local_done.set!
  }
  
  # Keep consuming |inner| until it doesn't match; it must match at least one.
  # The argument should be a Proc that generates bytecode when called.
  many: |inner| {
    local_retry = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    # push a false to indicate that no matches have occurred yet
    g.push_false
    
    local_retry.set!
    
    # Store captures for restoration
    g.push_temp_captures
    
    inner.call
    
    # Success, accept captures and try again, popping the last boolean
    # to push a true to indicate at least one match was made.
    g.pop_to_accept_captures
    g.pop; g.push_true
    g.goto(local_retry)
    
    # Failure, reject captures and continue
    local_fail.set!
    g.pop_to_reject_captures
    g.overall_fail = old_fail # reset fail
    
    # If at least one match was not found, it is an overall failure
    g.goto_if_false(g.overall_fail)
  }
  
  # Keep consuming |inner| until it doesn't match; it will not cause backtrack.
  # The argument should be a Proc that generates bytecode when called.
  kleene: |inner| {
    local_retry = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    local_retry.set!
    
    # Store captures for restoration
    g.push_temp_captures
    
    inner.call
    
    # Success, accept captures and try again
    g.pop_to_accept_captures
    g.goto(local_retry)
    
    # Failure, reject captures and continue
    local_fail.set!
    g.pop_to_reject_captures
    g.overall_fail = old_fail # reset fail
  }
  
  # Positive matching predicate that consumes no input.
  # The argument should be a Proc that generates bytecode when called.
  pos_predicate: |inner| {
    local_done = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    # Store index and captures for backtracking
    g.push_temp_captures
    g.push_idx
    
    inner.call
    
    # Success, but do not consume input, so backtrack index but keep captures
    g.pop_to_set_idx
    g.pop_to_accept_captures
    g.overall_fail = old_fail # reset fail
    g.goto(local_done)
    
    # Failure, backtrack index and captures
    local_fail.set!
    g.pop_to_set_idx
    g.pop_to_reject_captures
    g.overall_fail = old_fail
    g.goto(g.overall_fail)
    
    local_done.set!
  }
  
  # Negative matching predicate that consumes no input.
  # The argument should be a Proc that generates bytecode when called.
  neg_predicate: |inner| {
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    # Store index and captures for backtracking
    g.push_temp_captures
    g.push_idx
    
    inner.call
    
    # Success => Failure, backtrack index and captures
    g.pop_to_set_idx
    g.pop_to_reject_captures
    g.overall_fail = old_fail # reset fail
    g.goto(g.overall_fail)
    
    # Failure => Success, backtrack index but keep captures
    local_fail.set!
    g.pop_to_set_idx
    g.pop_to_accept_captures
    g.overall_fail = old_fail
  }
  
  # Call the compiled rule by |name| and continue or fail based on the result.
  call: |name| {
    local_done = g.new_label
    
    g.push_temp_captures
    
    g.push_self
      g.push_subject
      g.push_idx
    g.send(name, 2)
    g.dup_top # duplicate the result so one will be left after the if_true check
    g.goto_if_true(local_done)
    
    # Failure, reject index and captures
    g.pop # reject idx (which is actually null here)
    g.pop_to_reject_captures
    g.goto(g.overall_fail)
    
    # Success, accept new index and captures
    local_done.set!
    g.pop_to_set_idx # set to the new index given by the call's return value
    g.pop_to_accept_captures
  }
  
  capture: |*metadata| {
    g.push_captures
      g.push_idx
      metadata.each |primitive| { g.push_literal(primitive) }
      g.make_array(metadata.size)
      g.make_array(2)
    g.send(:push, 1)
    g.pop
  }
}
