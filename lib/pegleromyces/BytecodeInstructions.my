##
# The following code is based on code from Pegarus by Brian Shirai.
# A link to the code in question and the relevant license is reproduced below.
# 
# https://github.com/brixen/pegarus/blob/master/lib/pegarus/rubinius/compiler.rb
# 
# Copyright (c) 2014, Brian Shirai
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. Neither the name of the library nor the names of its contributors may be
#    used to endorse or promote products derived from this software without
#    specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import "BytecodeHelpers.my"


# This set of instructions is not directly related to those in Instructions, as
# those are not necessarily suitable for direct translation to the Rubinius VM.
#
BytecodeInstructions < BasicObject {
  
  Constructions << {
    AnyCharacter    << { bytecode: |m| m.any(1) }
    Character       << { bytecode: |m| m.char(code.chr) }
    CharacterString << { bytecode: |m| m.char(codes.map(&:chr).join) }
    CharacterSet    << { bytecode: |m| m.set(codes.map(&:chr).join) }
    CharacterRange  << { bytecode: |m|
      codes = Range.new(start,stop); m.set(codes.map(&:chr).join)
    }
    
    NegativePredicate << { bytecode: |m|
      m.neg_predicate(
        &{ inner.bytecode(m) }
        inner.bytecode_can_capture
      )
    }
    PositivePredicate << { bytecode: |m|
      m.pos_predicate(
        &{ inner.bytecode(m) }
        inner.bytecode_can_capture
      )
    }
    OneOrMore << { bytecode: |m|
      m.many(
        &{ inner.bytecode(m); inlaid.?call }
        inner.bytecode_can_capture
      )
    }
    ZeroOrOne << {
      bytecode: |m| {
        m.choice(
          &{ inner.bytecode(m) }
          &{ }
          inner.bytecode_can_capture
        )
      }
    }
    ZeroOrMore << { bytecode: |m|
      m.kleene(
        &{ inner.bytecode(m); inlaid.?call }
        inner.bytecode_can_capture
      )
    }
    OrderedChoice << {
      bytecode: |m| {
        m.choice(
          &{ first.bytecode(m) }
          &{ second.bytecode(m) }
          first.bytecode_can_capture
        )
      }
    }
    Concatenation << { bytecode: |m|
      first.bytecode(m); second.bytecode(m)
    }
    
    NamedCapture << {
      bytecode: |m| {
        (inner.is_a?(OneOrMore) || inner.is_a?(ZeroOrMore)) &? (
          inner.inlaid = &{ m.capture(:m_split, captargs) }
          m.capture(:m_start)
          inner.bytecode(m)
          m.capture(:m_end, captargs)
        ) ?? (
          m.capture(:c_start)
          inner.bytecode(m)
          m.capture(:c_end, captargs)
        )
      }
    }
    
    NamedTextCapture << {
      bytecode: |m| {
        m.capture(:s_start)
        inner.bytecode(m)
        m.capture(:s_end, captargs)
      }
    }
    
    NamedTokenCapture << {
      bytecode: |m| {
        m.capture(:t_start)
        inner.bytecode(m)
        m.capture(:t_end, captargs)
      }
    }
    
    Reduction << {
      bytecode: |m| {
        m.capture(:r_start)
        inner.bytecode(m)
        m.capture(:r_end, captargs)
      }
    }
    
    # Hints for optimization (skip saving of temp captures for primitives)
    AnyCharacter      << { bytecode_can_capture: false }
    Character         << { bytecode_can_capture: false }
    CharacterString   << { bytecode_can_capture: false }
    CharacterSet      << { bytecode_can_capture: false }
    CharacterRange    << { bytecode_can_capture: false }
    NegativePredicate << { bytecode_can_capture: inner.bytecode_can_capture }
    PositivePredicate << { bytecode_can_capture: inner.bytecode_can_capture }
    OneOrMore         << { bytecode_can_capture: inner.bytecode_can_capture }
    ZeroOrOne         << { bytecode_can_capture: inner.bytecode_can_capture }
    ZeroOrMore        << { bytecode_can_capture: inner.bytecode_can_capture }
    OrderedChoice     << { bytecode_can_capture: first.bytecode_can_capture
                                             || second.bytecode_can_capture }
    Concatenation     << { bytecode_can_capture: first.bytecode_can_capture
                                             || second.bytecode_can_capture }
    NamedCapture      << { bytecode_can_capture: true }
    NamedTextCapture  << { bytecode_can_capture: true }
    NamedTokenCapture << { bytecode_can_capture: true }
    Reduction         << { bytecode_can_capture: true }
  }
  
  
  var g # The generator to use
  
  # Match any character, |count| number of times.
  any: |count| {
    g.push_idx
    g.push_int(count)
    g.send(:"+", 1)
    
    g.push_subject
    g.send(:size, 0)
    g.send(:"<=", 1)
    g.goto_if_false(g.overall_fail)
    
    g.push_int(count)
    g.increment_idx
  }
  
  # Match the given |string| of characters, one time.
  char: |string| {
    g.setup_unwind(g.overall_fail, 0) # "rescue" to overall fail
    
    g.push_literal(string)
      g.push_subject
      g.push_idx
      g.push_int(string.size)
    g.send(:compare_substring, 3)
      g.meta_push_0
      
    g.pop_unwind # end rescued block
    
    g.goto_if_not_equal(g.overall_fail)
    
    g.push_int(string.size)
    g.increment_idx
  }
  
  # Match if the character is included in the given |string|, one time.
  set: |string| {
    local_done = g.new_label
    local_early_fail = g.new_label
    
    g.push_literal(string)
      g.push_subject_at_idx
      g.dup_top
      g.goto_if_false(local_early_fail)
      g.meta_push_0
    g.send(:find_string, 2)
    g.goto_if_false(g.overall_fail)
    g.goto(local_done)
    
    local_early_fail.set!
    g.pop # pop literal string
    g.pop # pop subject_at_idx
    g.goto(g.overall_fail)
    
    local_done.set!
    g.meta_push_1
    g.increment_idx
  }
  
  # An ordered choice between |first| and |second|.
  # Each argument should be a Proc that generates bytecode when called.
  choice: |first, second, first_can_capture| {
    local_done = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    # Store index and captures for backtracking in case of failure
    if(first_can_capture) { g.push_temp_captures }
    g.push_idx
    
    first.call
    
    # Success, throw away backtrack entry
    g.pop # keep idx
    if(first_can_capture) { g.pop_to_accept_captures }
    g.overall_fail = old_fail # reset fail
    g.goto(local_done)
    
    # Failure, backtrack index and captures
    local_fail.set!
    g.pop_to_set_idx
    if(first_can_capture) { g.pop_to_reject_captures }
    g.overall_fail = old_fail
    
    second.call
    
    local_done.set!
  }
  
  # Keep consuming |inner| until it doesn't match; it must match at least one.
  # The argument should be a Proc that generates bytecode when called.
  many: |inner, inner_can_capture| {
    local_retry = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    # push a false to indicate that no matches have occurred yet
    g.push_false
    
    local_retry.set!
    
    # Store captures for restoration
    if(inner_can_capture) { g.push_temp_captures }
    
    inner.call
    
    # Success, accept captures and try again, popping the last boolean
    # to push a true to indicate at least one match was made.
    if(inner_can_capture) { g.pop_to_accept_captures }
    g.pop; g.push_true
    g.goto(local_retry)
    
    # Failure, reject captures and continue
    local_fail.set!
    if(inner_can_capture) { g.pop_to_reject_captures }
    g.overall_fail = old_fail # reset fail
    
    # If at least one match was not found, it is an overall failure
    g.goto_if_false(g.overall_fail)
  }
  
  # Keep consuming |inner| until it doesn't match; it will not cause backtrack.
  # The argument should be a Proc that generates bytecode when called.
  kleene: |inner, inner_can_capture| {
    local_retry = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    local_retry.set!
    
    # Store captures for restoration
    if(inner_can_capture) { g.push_temp_captures }
    
    inner.call
    
    # Success, accept captures and try again
    if(inner_can_capture) { g.pop_to_accept_captures }
    g.goto(local_retry)
    
    # Failure, reject captures and continue
    local_fail.set!
    if(inner_can_capture) { g.pop_to_reject_captures }
    g.overall_fail = old_fail # reset fail
  }
  
  # Positive matching predicate that consumes no input.
  # The argument should be a Proc that generates bytecode when called.
  pos_predicate: |inner, inner_can_capture| {
    local_done = g.new_label
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    # Store index and captures for backtracking
    if(inner_can_capture) { g.push_temp_captures }
    g.push_idx
    
    inner.call
    
    # Success, but do not consume input, so backtrack index but keep captures
    g.pop_to_set_idx
    if(inner_can_capture) { g.pop_to_accept_captures }
    g.overall_fail = old_fail # reset fail
    g.goto(local_done)
    
    # Failure, backtrack index and captures
    local_fail.set!
    g.pop_to_set_idx
    if(inner_can_capture) { g.pop_to_reject_captures }
    g.overall_fail = old_fail
    g.goto(g.overall_fail)
    
    local_done.set!
  }
  
  # Negative matching predicate that consumes no input.
  # The argument should be a Proc that generates bytecode when called.
  neg_predicate: |inner, inner_can_capture| {
    local_fail = g.new_label
    old_fail = g.overall_fail
    g.overall_fail = local_fail
    
    # Store index and captures for backtracking
    if(inner_can_capture) { g.push_temp_captures }
    g.push_idx
    
    inner.call
    
    # Success => Failure, backtrack index and captures
    g.pop_to_set_idx
    if(inner_can_capture) { g.pop_to_reject_captures }
    g.overall_fail = old_fail # reset fail
    g.goto(g.overall_fail)
    
    # Failure => Success, backtrack index and cannot keep captures either (incomplete)
    local_fail.set!
    g.pop_to_set_idx
    if(inner_can_capture) { g.pop_to_reject_captures }
    g.overall_fail = old_fail
  }
  
  # Call the compiled rule by |name| and continue or fail based on the result.
  call: |name, memoize=true| {
    result_check      = g.new_label
    memo_result_check = g.new_label
    local_success     = g.new_label
    local_fail        = g.new_label
    
    # Push @captures onto stack and set @captures to a new empty array
    g.push_temp_captures
    
    if(memoize) {
      # Check if a memoized result exists;
      # If one does, go straight to memo_result_check label
      g.memo_or_eq_new_hash(name)
      g.goto_if_memo_for_idx(name, memo_result_check)
    }
    
    # Call the method; sets @captures and returns the result_idx (or nil)
    g.push_self
      g.push_subject
      g.push_idx
    g.send(name, 2)
    
    # Check result and memoize the result
    result_check.set!
    g.copy_result_to_memo(name)
    g.dup_top
    g.goto_if_true(local_success)
    g.goto(local_fail)
    
    if(memoize) {
      # Check result, but skip memo copy
      memo_result_check.set!
      g.dup_top
      g.goto_if_true(local_success)
      g.goto(local_fail)
    }
    
    # Failure, reject index and captures
    local_fail.set!
    g.pop # reject idx (which is actually null here)
    g.pop_to_reject_captures
    g.goto(g.overall_fail)
    
    # Success, accept new index and captures
    local_success.set!
    g.pop_to_set_idx # set to the new index given by the call's return value
    g.pop_to_accept_captures
  }
  
  capture: |*metadata| {
    g.push_captures
        g.push_idx
        g.push_literal_or_array(metadata)
        g.make_array(2)
      g.make_array(1)
    g.send(:concat, 1)
    g.pop
  }
}
