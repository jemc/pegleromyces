
Processor < BasicObject {
  var string
  var capture_tokens
  var builder
  
  storage starts
  var gathered: []
  
  var cidx_stack: [] # A FILO stack of start indices for captures
  var capt_stack: [] # A FILO stack of Hashes with capture names, values
  
  pop_layer:  capt_stack.pop
  push_layer: capt_stack.push(::Hash.new)
  
  process_all: capture_tokens.each |idx, metadata| {
    type   = metadata.first
    captor = metadata.last
    
    value = null
    type == :start && (
      # Note the starting index of the text capture
      cidx_stack.push(idx)
    true) || (type == :end && (
      # Pick up the captured reduction, or if no reduction found
      # slice the string with the given indices to get a text value
      captures = capt_stack.last
      start_idx = cidx_stack.pop
      value = captures.fetch(idx) { string.slice(start_idx, idx) }
      captures.store(captor.name, value)
    true)) || (type == :comp_start && (
      # Push a new layer of composition onto the stack
      push_layer
    true)) || (type == :comp_end && (
      captures = pop_layer
      
      env = captor.new_environment
      env.captures = captures
      env.builder = builder
      
      # The '!' operator on the environment invokes the action to get a value
      # Store with the string index as the key so the reduction can be captured
      value = !env
      capt_stack.last.store(idx, value)
    true))
  }
  
  process: push_layer; process_all; pop_layer
}
