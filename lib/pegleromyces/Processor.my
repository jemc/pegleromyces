
Processor < BasicObject {
  var string
  var capture_items
  var builder
  
  storage starts
  var gathered: []
  
  var cidx_stack: [] # A FILO stack of start indices for captures
  var midx_stack: [] # A FILO stack of start indices for multiplicit captures
  var ridx_stack: [] # A FILO stack of start indices for reductions
  var capt_stack: [] # A FILO stack of Hashes with capture names, values
  
  memoize line_map_for: |string| {
    idx_hash = ::Hash.new
    idx_hash[0] = 0
    count = 0
    idx = 0
    loop {
      idx = string.index("\n", idx + 1)
      idx || break
      count = count + 1
      idx_hash[idx] = count
    }
    idx_hash
  }
  
  position_of: |idx, string| {
    nl_idx = string.rindex("\n", idx)
    row = line_map_for(string).fetch(nl_idx)
    col = idx - nl_idx
    [row, col]
  }
  
  Token < Object {
    var type
    var text
    var line
    
    inspect: [type, text, line].inspect
    to_s:    [type, text, line].inspect
    
    sym:      text.to_sym
    float:    send("Float", text)
    integer:  send("Integer", text)
  }
  
  pop_layer:  capt_stack.pop
  push_layer: capt_stack.push(::Hash.new)
  
  setup:
    push_layer
  
  final_captures:
    pop_layer
      .select |k,v| { k.is_a?(Symbol) }
      .map    |k,v| { [k,v.last] }
      .to_h
  
  process: setup; process_each; final_captures
  
  process_each: capture_items.each |idx, metadata| {
    type     = metadata[0]
    captargs = metadata[1] || []
    send(type, idx, *captargs)
  }
  
  # Start of a named capture
  c_start: |idx| {
    # Note the starting index of the text capture
    cidx_stack.push(idx)
  }
  
  # End of a named capture
  c_end: |idx, name| {
    captures = capt_stack.last
    start_idx = cidx_stack.pop
    
    # Pick up the captured reduction, if its start and end 
    # indices are within the bounds we are looking for.
    use_reduction = false
    value = captures[idx]
    value && (
      loc = value.first
      value = value.last
      (loc.first>=start_idx) && (loc.last<=idx) && (
        use_reduction = true
      ) || (
        value = null
      )
    )
    
    # If the reduction is not found and the string length is not zero
    # slice the string with the given indices to get a text value.
    !use_reduction && !(start_idx==idx) && (
      value = string.slice(start_idx, idx-start_idx)
    )
    
    store_value = [[start_idx, idx], value]
    captures.store(idx, store_value)
    captures.store(name, store_value)
  }
  
  # Start of a named text capture
  s_start: |idx| {
    # Note the starting index of the text capture
    cidx_stack.push(idx)
  }
  
  # End of a named text capture
  s_end: |idx, name| {
    captures = capt_stack.last
    start_idx = cidx_stack.pop
    
    value = string.slice(start_idx, idx-start_idx)
    store_value = [[start_idx, idx], value]
    captures.store(idx, store_value)
    captures.store(name, store_value)
  }
  
  # Start of a named token capture
  t_start: |idx| {
    # Note the starting index of the text capture
    cidx_stack.push(idx)
  }
  
  # End of a named token capture
  t_end: |idx, name| {
    captures = capt_stack.last
    start_idx = cidx_stack.pop
    pos = position_of(start_idx, string)
    
    value = Token.new(
      type: name
      text: string.slice(start_idx, idx - start_idx)
      line: pos.first
    )
    store_value = [[start_idx, idx], value]
    captures.store(idx, store_value)
    captures.store(name, store_value)
  }
  
  # Start of a multiplicit capture
  m_start: |idx| {
    midx_stack.push(idx)
    c_start(idx)
  }
  
  # Split of a multiplicit capture
  m_split: |idx, name| {
    c_end(idx, name)
    c_start(idx)
  }
  
  # End of a multiplicit capture
  m_end: |idx, name| {
    captures = capt_stack.last
    start_idx = midx_stack.pop
    cidx_stack.pop # Discard cidx pushed by m_start/end calling c_start
    
    # Try to find a group of "anonymous" captures by index first
    value = []
    captures.each |k,v| {
      (k.is_a?(Fixnum) && k<=idx && k>start_idx) && (
        loc = v.first
        (loc.first>=start_idx) && (
          value.push(v.last)
        )
      )
    }
    
    # If the group is empty and the string length is not zero
    # slice the string with the given indices to get a text value
    (value.empty? && !(start_idx==idx)) && (
      value = string.slice(start_idx, idx-start_idx)
    )
    
    store_value = [[start_idx, idx], value]
    captures.store(idx, store_value)
    captures.store(name, store_value)
  }
  
  # Start of a reduction
  r_start: |idx| (
    # Push a new layer of reduction context onto the stack
    push_layer
    ridx_stack.push(idx)
  )
  
  # End of a reduction
  r_end: |idx, code, *args| {
    captures = pop_layer
    start_idx = ridx_stack.pop
    
    # Set up the reduction environment
    code.scope = reduction_env_cscope
    reduction_env.builder = builder
    reduction_env.captures = captures.map |k,v| { [k,v.last] }.to_h
    
    # Invoke the reduction action to get a value
    # Store with the string index as the key so the value can be recaptured
    value = code.invoke(
      code.name
      Patterns::Reduction::Environment
      reduction_env
      []
      null
    )
    store_value = [[start_idx, idx], value]
    capt_stack.last.store(idx, store_value)
  }
  
  var reduction_env:
    Patterns::Reduction::Environment { }
  var reduction_env_cscope:
    ::Rubinius::ConstantScope.new(Patterns::Reduction::Environment) # TODO: fix
}
