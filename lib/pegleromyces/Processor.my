
Processor < BasicObject {
  var string
  var capture_tokens
  var builder
  
  storage starts
  var gathered: []
  
  var cidx_stack: [] # A FILO stack of start indices for captures
  var midx_stack: [] # A FILO stack of start indices for multiplicit captures
  var capt_stack: [] # A FILO stack of Hashes with capture names, values
  
  pop_layer:  capt_stack.pop
  push_layer: capt_stack.push(::Hash.new)
  
  process: push_layer; process_each; pop_layer
  
  process_each: capture_tokens.each |idx, metadata| {
    type   = metadata.first
    captor = metadata.last
    send(type, idx, captor)
  }
  
  c_start: |idx, captor| {
    # Note the starting index of the text capture
    cidx_stack.push(idx)
  }
  
  c_end: |idx, captor| {
    captures = capt_stack.last
    start_idx = cidx_stack.pop
    
    # Pick up the captured reduction
    # If the reduction is not found and the string length is not zero
    # slice the string with the given indices to get a text value
    value = captures.fetch(idx) {
      !(start_idx==idx) && string.slice(start_idx, idx-start_idx)
    }
    # p([captor.name, start_idx, idx, value])
    
    captures.store(idx, value)
    captures.store(captor.name, value)
  }
  
  m_start: |idx, captor| {
    midx_stack.push(idx)
    c_start(idx, captor)
  }
  
  m_split: |idx, captor| {
    c_end(idx, captor)
    c_start(idx, captor)
  }
  
  m_end: |idx, captor| {
    captures = capt_stack.last
    start_idx = midx_stack.pop
    
    # Try to find a group of "anonymous" captures by index first
    value = []
    captures.each |k,v| {
      (k.is_a?(Fixnum) && k<=idx && k>start_idx) && value.push(v)
    }
    
    # If the group is empty and the string length is not zero
    # slice the string with the given indices to get a text value
    (value.empty? && !(start_idx==idx)) && (
      value = string.slice(start_idx, idx-start_idx)
    )
    
    captures.store(idx, value)
    captures.store(captor.name, value)
  }
  
  r_start: |idx, captor| (
    # Push a new layer of reduction context onto the stack
    push_layer
  )
  
  r_end: |idx, captor| {
    captures = pop_layer
    
    env = captor.new_environment
    env.captures = captures
    env.builder = builder
    
    # The '!' operator on the environment invokes the action to get a value
    # Store with the string index as the key so the reduction can be captured
    value = !env
    capt_stack.last.store(idx, value)
  }
}
