
Grammar < BasicObject, Patterns::ShorthandMethods {
  
  Rule < Patterns::UnaryBase {
    construct_rule: inner.construct
    construct: RuleReference.new(name:name)
  }
  
  RuleReference < Constructions::UnaryBase {
    var name
    sequence: [[:call, name]]
    bytecode: |m| m.call(name)
  }
  
  var rule_table: Hash.new
  var rule_table: Hash.new
  
  # Force evaluation of the rule tree in a way that
  # doesn't get stuck in an infinite recursion.
  construct_all_rules: {
    rules.root.construct_rule
    seen_keys = []
    loop {
      new_keys = rule_table.keys - seen_keys
      new_keys.empty? && break
      new_keys.each |key| {
        rule_table[key].construct_rule
        seen_keys.push(key)
      }
    }
  }
  
  # TODO: Don't pollute toplevel
  ::Token < Object {
    var type
    var text
    var line
    
    inspect: [type, text, line].inspect
    to_s:    [type, text, line].inspect
    
    sym:      text.to_sym
    float:    send("Float", text)
    integer:  send("Integer", text)
  }
  
  [decorators]
  
  # TODO: streamline syntax for this definition to make it more intuitive
  token: Decorator {
    apply: |meme| {
      orig_meme = meme.dup
      meme.body = Proc.new {
        Patterns::Reduction.new(
          inner: (orig_meme.result)[:text]
          args: [meme.name]
          block: Proc.new |name| {
            ::Token.new(
              type: :"t_"name""
              text: text
              # TODO: get row/col info from parser
            )
          }
        )
      }
    }
    [transforms]
    cache: true
  }
  
  var rule: Decorator {
    apply: |meme| {
      name = meme.name
      # TODO: use some kind of Decorator#wrap mechanism instead
      meme.target.declare_meme(name, [:memoize]) {
        outer_self = self
        rule = Rule {
          name: name
          inner: meme.result_for(outer_self)
        }
        rule_table[name] = rule
        rule
      }
    }
    [transforms]
    expose: false # Exposing the original meme would overwrite the wrapped one
  }
  
  [rules]
  rule root: Patterns::AnyCharacter.new.*
}
