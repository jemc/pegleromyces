
Grammar < BasicObject, Patterns::ShorthandMethods {
  
  Rule < Patterns::UnaryBase {
    construct_rule: inner.construct
    construct: RuleReference.new(name:name)
  }
  
  RuleReference < Constructions::UnaryBase {
    var name
    sequence: [[:call, name]]
    bytecode: |m| m.call(name)
  }
  
  var rule_table: Hash.new
  var rule_table: Hash.new
  
  # Force evaluation of the rule tree in a way that
  # doesn't get stuck in an infinite recursion.
  construct_all_rules: {
    rules.root.construct_rule
    seen_keys = []
    loop {
      new_keys = rule_table.keys - seen_keys
      new_keys.empty? && break
      new_keys.each |key| {
        rule_table[key].construct_rule
        seen_keys.push(key)
      }
    }
  }
  
  [decorators]
  
  # TODO: streamline syntax for this definition to make it more intuitive
  token: Decorator {
    apply: |meme| {
      orig_meme = meme.dup
      meme.body = Proc.new { orig_meme.result.token(:"t_"meme.name"") }
    }
    [transforms]
    cache: true
  }
  
  var rule: Decorator {
    apply: |meme| {
      name = meme.name
      # TODO: use some kind of Decorator#wrap mechanism instead
      meme.target.declare_meme(name, [:memoize]) {
        outer_self = self
        rule = Rule {
          name: name
          inner: meme.result_for(outer_self)
        }
        rule_table[name] = rule
        rule
      }
    }
    [transforms]
    expose: false # Exposing the original meme would overwrite the wrapped one
  }
  
  [rules]
  rule root: Patterns::AnyCharacter.new.*
}
