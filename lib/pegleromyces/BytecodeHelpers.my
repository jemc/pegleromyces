
BytecodeHelpers < BasicObject {
  ##
  # Bytecode Generation Helper Methods
  
  var overall_fail: new_label
  
  g: self # For consistency
  
  puts_string: |string|
    g.push_rubinius; g.push_literal(string); g.send(:puts, 1, true); g.pop
  
  inspect_top:
    g.dup_top; g.push_rubinius; g.swap; g.send(:p, 1, true); g.pop
  
  set_subject:   g.set_local  (0)
  push_subject:  g.push_local (0)
  set_idx:       g.set_local  (1)
  push_idx:      g.push_local (1)
  set_captures:  g.set_ivar   (:"@captures")
  push_captures: g.push_ivar  (:"@captures")
  
  pop_to_set_idx:
    g.set_idx; g.pop
  
  push_temp_captures:
    g.push_captures; g.make_array(0); g.set_captures; g.pop
  
  pop_to_reject_captures:
    g.set_captures; g.pop
  
  pop_to_accept_captures:
    g.push_captures; g.send(:concat, 1); g.set_captures; g.pop
  
  push_subject_at_idx:
    g.push_subject; g.push_idx; g.send(:chr_at, 1)
  
  # Increment the idx local by the current number at the top of the stack
  # Saves the new idx to @highest_idx ivar if it is highest
  increment_idx: {
    g.push_idx
    g.send(:"+", 1)
    g.set_idx
    g.dup_top
    g.push_ivar(:"@highest_idx")
    g.send(:">", 1)
    not_highest_idx_label = g.new_label
    g.goto_if_false(not_highest_idx_label)
    g.set_ivar(:"@highest_idx")
    not_highest_idx_label.set!
    g.pop
  }
  
  # Begin a compiled parser method
  rule_start: {
    # 2 argument: (subject, idx)
    g.required_args = 2
    g.total_args    = 2
    g.splat_index   = null
    
    g.local_count = 2
    g.local_names = [:subject, :idx]
  }
  
  # Wrap up a compiled parser method
  rule_finish: {
    overall_done = g.new_label
    
    # end
    g.push_idx
    g.goto(overall_done)
    
    # fail
    g.overall_fail.set!
    g.push_nil
    
    overall_done.set!
    g.ret
    g.close
  }
  
  push_literal_array: |ary|
    ary.each |lit| { g.push_literal_or_array(lit) }; make_array(ary.size)
  
  push_literal_or_array: |item|
    item.is_a?(Array) && (push_literal_array(item); true) || push_literal(item)
}
