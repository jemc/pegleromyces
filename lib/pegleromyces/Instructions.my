
Instructions < EmptyObject {
  
  # Test the character pointed to by the current index into the subject.
  # Continue if the character |code| is equal, otherwise fail.
  char: |code|
    (subject.at(idx) == code)
      && (self.ip = ip + 1; self.idx = idx + 1)
      || (self.ip = null)
  
  # Move the instruction pointer forward by |label| instructions.
  jump: |label|
    self.ip = ip + label
  
  # Create a backtrack entry on the stack, pointing |label| instructions ahead.
  choice: |label| {
    self.ip = ip + 1
    stack.push([ip + label, idx, captures.dup])
  }
  
  # Push return address onto the stack and jump |label| instructions ahead.
  call: |label| {
    self.ip = ip + label
    stack.push(ip + 1)
  }
  
  # Return from a call by popping the return address and jumping to it.
  # It is assumed that the top of the stack is a return address from a :call.
  return:
    self.ip = stack.pop.to_i
  
  # Pop and discard the backtrack entry from the stack and jump to |label|.
  # It is assumed that the top of the stack is a backtrack entry from a :choice.
  commit: |label|
    self.ip = stack.pop.to_a.first
  
  # Note the current subject index and the captor to notify in post-processing.
  capture: |captor|
    captures.push([idx, captor])
  
  # Pop the backtrack entry off the stack and copy the state from it,
  # effectively pursuing the alternative posed by the last :choice.
  fail:
    self.stack.empty?
      && ErrorCondition.new
      || (
        entry = stack.pop.to_a
        self.captures = entry.pop # Pop each entry item
        self.idx      = entry.pop # and restore it to the relevant variable
        self.ip       = entry.pop # (popping implies reverse order)
      )
}
