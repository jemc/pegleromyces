
Instructions < EmptyObject {
  
  ##
  # Basic Instructions
  
  # Test the character pointed to by the current index into the subject.
  # Continue if the character |code| is equal, otherwise fail.
  char: |code|
    (subject.at(idx) == code)
      && (self.ip = ip + 1; self.idx = idx + 1)
      || (self.ip = null) # failure
  
  # Move the instruction pointer forward by |label| instructions.
  jump: |label|
    self.ip = ip + label
  
  # Create a backtrack entry on the stack, pointing |label| instructions ahead.
  choice: |label| {
    stack.push([ip + label, idx, captures.dup])
    self.ip = ip + 1
  }
  
  # Push two-part return address onto the stack and goto start of |new_ipk|
  call: |new_ipk| {
    stack.push([ip+1, ipk])
    self.ip = 0
    self.ipk = new_ipk
  }
  
  # Return from a call by popping the return address and jumping to it.
  # It is assumed that the top of the stack is a return address from a :call.
  return: {
    addr = stack.pop
    addr && (
      self.ipk = addr.pop
      self.ip  = addr.pop
      true
    ) || end
  }
  
  # Pop and discard the backtrack entry from the stack and jump to |label|.
  # It is assumed that the top of the stack is a backtrack entry from a :choice.
  commit: |label| {
    stack.pop
    self.ip = ip + label
  }
  
  # Note the current subject index and the given metadata for post-processing.
  capture: |metadata| {
    captures.push([idx, metadata])
    self.ip = ip + 1
  }
  
  # Pop the backtrack entry off the stack and copy the state from it,
  # effectively pursuing the alternative posed by the last :choice.
  handle_fail:
    self.stack.empty?
      && ErrorCondition.new
      || (
        entry = stack.pop
        size = entry.size
        size == 3 && ( # backtrack
          self.captures = entry.pop
          self.idx      = entry.pop
          self.ip       = entry.pop
          true
        ) || ( # return and mark fail
          size == 2 && (
            self.ipk = entry.pop
            self.ip  = null
            true
          ) || ErrorCondition.new
        )
      )
  
  # Signal a successful match at the end of the complete pattern
  end:
    self.ip = true
  
  ##
  # Optimized Instructions
  #
  # These instructions could be expressed in terms of the Basic Instructions,
  # but are more efficiently executed if given special implementations.
  
  # Like char, but accept any char whose code is a valid key in |table|
  charset: |table|
    (code=subject.at(idx); code && table.key?(code))
      && (self.ip = ip + 1; self.idx = idx + 1)
      || (self.ip = null) # failure
  
  # Like char, but accept any char whose code is between |start| and |end|
  charrange: |start, end|
    (code=subject.at(idx); code && code>=start && code<=end)
      && (self.ip = ip + 1; self.idx = idx + 1)
      || (self.ip = null) # failure
  
  # (Kleene star applied to a charset)
  span: |table| loop {
    (code=subject.at(idx); code && table.key?(code))
      && (self.idx = idx + 1)
      || (self.ip = ip + 1; break)
  }
  
  # Match any character, |count| number of times.
  any: |count|
    (self.idx + count > subject.size)
      && (self.ip = null; true) # failure
      || (
        self.ip = ip + 1
        self.idx = idx + count
      )
  
  # Update the state for the backtrack entry on the top of the stack
  # but don't change the fail address; then jump to |label|.
  partial_commit: |label| {
    entry = stack.pop
    stack.push([entry.first, idx, captures.dup])
    self.ip = ip + label
  }
  
  # Pop the backtrack entry and restore state but jump to |label|
  # instead of jumping to the popped fail address.
  back_commit: |label| {
    entry = stack.pop
    self.captures = entry.pop
    self.idx      = entry.pop
    self.ip = ip + label
  }
  
  # Pop a backtrack entry off the stack and discard it, then fail.
  fail_twice: {
    self.stack.empty?
      && ErrorCondition.new
      || stack.pop
    handle_fail
  }
  
}
