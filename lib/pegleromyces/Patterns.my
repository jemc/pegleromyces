
Patterns < EmptyObject {
  
  ##
  # Basic types of patterns.
  
  Base < BasicObject { var name: parent_meme.name }
  UnaryBase  < Base { var inner }
  BinaryBase < Base { var first, var second }
  
  AnyCharacter      < Base { }
  Character         < Base { var code }
  CharacterString   < Base { var codes } # Concatenation for Characters
  CharacterSet      < Base { var codes } # OrderedChoice for Characters
  CharacterRange    < Base { var start, var end }
  
  NegativePredicate < UnaryBase { }
  PositivePredicate < UnaryBase { }
  OneOrMore         < UnaryBase { }
  ZeroOrOne         < UnaryBase { }
  ZeroOrMore        < UnaryBase { }
  OrderedChoice     < BinaryBase { }
  Concatenation     < BinaryBase { }
  
  NamedCapture      < UnaryBase { }
  Reduction         < UnaryBase { var block }
  
  ##
  # Shorthand methods for creating primitive patterns
  
  ShorthandMethods < EmptyObject {
    any:                   AnyCharacter.new
    char:  |character|        Character.new(code:character.ord)
    str:   |string|     CharacterString.new(codes:string.each_char.map(&:ord))
    set:   |string|        CharacterSet.new(codes:string.each_char.map(&:ord))
    range: |start, end|  CharacterRange.new(start:start.ord, end:end.ord)
    r:     |pattern, &block|  Reduction.new(inner:pattern, block:block)
  }
  
  ##
  # Operator overloading for combining and modifying patterns.
  #
  # Each operation returns a new Pattern object composed of the operands
  # so that complex grammars can be specified with relatively succint syntax.
  
  Base << {
    "!":         NegativePredicate .new(inner:self)
    "/": |other| OrderedChoice     .new(first:self, second:other)
    "+": |other=false|
      other && Concatenation  .new(first:self, second:other)
            || OneOrMore      .new(inner:self)
    "-": |other=false|
      other && ErrorCondition .new() # TODO: add exception handling to Myco
            || ZeroOrOne      .new(inner:self)
    "*": |other=false|
      other && ErrorCondition .new()
            || ZeroOrMore     .new(inner:self)
    
    "[]": |name| NamedCapture .new(inner:self, name:name)
  }
  
  NegativePredicate << {
    # Invert the polarity of the predicate instead of nesting the predicate
    "!": PositivePredicate.new(inner:inner)
  }
  
  PositivePredicate << {
    # Invert the polarity of the predicate instead of nesting the predicate
    "!": NegativePredicate.new(inner:inner)
  }
  
  OrderedChoice << {
    # Build a right-associative tree if the first operand of another choice
    "/": |other| {
      self.second = OrderedChoice.new(first:self.second, second:other)
      self
    }
  }
  
  Concatenation << {
    # Build a right-associative tree if the first operand of another choice
    "+": |other=false| {
      other && (
        self.second = Concatenation.new(first:self.second, second:other)
        self
      ) || OneOrMore.new(inner:self)
    }
  }
  
  ##
  # Reduction and associated named captures implementation
  
  Reduction << {
    Environment < BasicObject {
      var captures # A Hash of capture names to values
      var builder # The fallback delegate for methods that are not capture names
      
      method_missing: |name, *args|
        captures.fetch(name) { builder.send(name, *args) }
      
      # Implement the action for the reduction in the '!' method.
      # It will have access to the captures via method_missing.
      "!": null
    }
    
    new_environment: {
      env = Patterns::Reduction::Environment { }
      env.component.declare_meme(:"!", &block)
      env
    }
  }
}
