
Patterns < EmptyObject {
  
  ##
  # Basic types of patterns.
  
  Base < BasicObject { var name: parent_meme.name }
  UnaryBase  < Base { var inner }
  BinaryBase < Base { var first, var second }
  
  AnyCharacter      < Base { }
  Character         < Base { var code }
  CharacterString   < Base { var codes } # Concatenation for Characters
  CharacterSet      < Base { var codes } # OrderedChoice for Characters
  CharacterRange    < Base { var start, var end }
  
  NegativePredicate < UnaryBase { }
  PositivePredicate < UnaryBase { }
  OneOrMore         < UnaryBase { }
  ZeroOrOne         < UnaryBase { }
  ZeroOrMore        < UnaryBase { }
  OrderedChoice     < BinaryBase { }
  Concatenation     < BinaryBase { }
  
  ##
  # Shorthand methods for creating primitive patterns
  
  ShorthandMethods < EmptyObject {
    any:                   AnyCharacter.new
    char:  |character|        Character.new(code:character.ord)
    str:   |string|     CharacterString.new(codes:string.each_char.map(&:ord))
    set:   |string|        CharacterSet.new(codes:string.each_char.map(&:ord))
    range: |start, end|  CharacterRange.new(start:start.ord, end:end.ord)
  }
  
  ##
  # Operator overloading for combining and modifying patterns.
  #
  # Each operation returns a new Pattern object composed of the operands
  # so that complex grammars can be specified with relatively succint syntax.
  
  Base << {
    "!":         NegativePredicate .new(inner:self)
    "/": |other| OrderedChoice     .new(first:self, second:other)
    "+": |other=false|
      other && Concatenation  .new(first:self, second:other)
            || OneOrMore      .new(inner:self)
    "-": |other=false|
      other && ErrorCondition .new() # TODO: add exception handling to Myco
            || ZeroOrOne      .new(inner:self)
    "*": |other=false|
      other && ErrorCondition .new()
            || ZeroOrMore     .new(inner:self)
  }
  
  NegativePredicate << {
    # Invert the polarity of the predicate instead of nesting the predicate
    "!": PositivePredicate.new(inner:inner)
  }
  
  PositivePredicate << {
    # Invert the polarity of the predicate instead of nesting the predicate
    "!": NegativePredicate.new(inner:inner)
  }
  
  OrderedChoice << {
    # Build a right-associative tree if the first operand of another choice
    "/": |other| {
      self.second = OrderedChoice.new(first:self.second, second:other)
      self
    }
  }
  
  Concatenation << {
    # Build a right-associative tree if the first operand of another choice
    "+": |other| {
      self.second = Concatenation.new(first:self.second, second:other)
      self
    }
  }
}
