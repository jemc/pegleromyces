
Patterns < EmptyObject {
  
  ##
  # Basic types of patterns.
  
  Base < BasicObject { var name: parent_meme.name }
  UnaryBase  < Base { var inner }
  BinaryBase < Base { var first, var second }
  
  AnyCharacter      < Base { }
  Character         < Base { var code }
  CharacterString   < Base { var codes } # Concatenation for Characters
  CharacterSet      < Base { var codes } # OrderedChoice for Characters
  CharacterRange    < Base { var start, var stop }
  
  NegativePredicate < UnaryBase { }
  PositivePredicate < UnaryBase { }
  OneOrMore         < UnaryBase { }
  ZeroOrOne         < UnaryBase { }
  ZeroOrMore        < UnaryBase { }
  OrderedChoice     < BinaryBase { }
  Concatenation     < BinaryBase { }
  
  NamedCapture      < UnaryBase { }
  NamedTextCapture  < UnaryBase { }
  NamedTokenCapture < UnaryBase { }
  Reduction         < UnaryBase { var block, var args: [] }
  
  ##
  # Shorthand methods for creating primitive patterns
  
  ShorthandMethods < EmptyObject {
    any:                   AnyCharacter.new
    char:  |character|        Character.new(code:character.ord)
    str:   |string|     CharacterString.new(codes:string.each_char.map(&:ord))
    set:   |string|        CharacterSet.new(codes:string.each_char.map(&:ord))
    range: |start, stop| CharacterRange.new(start:start.ord, stop:stop.ord)
    r:     |pattern, &block|  Reduction.new(inner:pattern, block:block)
  }
  
  ##
  # Operator overloading for combining and modifying patterns.
  #
  # Each operation returns a new Pattern object composed of the operands
  # so that complex grammars can be specified with relatively succint syntax.
  
  Base << {
    "!":         NegativePredicate .new(inner:self)
    "/": |other| OrderedChoice     .new(first:self, second:other)
    "+": |other=false|
      other &? Concatenation       .new(first:self, second:other)
            ?? OneOrMore           .new(inner:self)
    "-": |other=false|
      other &? ErrorCondition      .new() # TODO: add exception handling to Myco
            ?? ZeroOrOne           .new(inner:self)
    "*": |other=false|
      other &? ErrorCondition      .new()
            ?? ZeroOrMore          .new(inner:self)
    
    "[]": |name| NamedCapture      .new(inner:self, name:name)
    text: |name=:text|
                 NamedTextCapture  .new(inner:self, name:name)
    token: |name|
                 NamedTokenCapture .new(inner:self, name:name)
    
    [private]
    
    # Add |other| to |orig| in a right-associative tree of type |type|
    binary_right_assoc: |orig, other, type| {
      cursor = orig
      loop {
        unless(cursor.second.is_a?(type)) { break }
        cursor = cursor.second
      }
      cursor.second = type.new(first:cursor.second, second:other)
      orig
    }
  }
  
  NegativePredicate << {
    # Invert the polarity of the predicate instead of nesting the predicate
    "!": PositivePredicate.new(inner:inner)
  }
  
  PositivePredicate << {
    # Invert the polarity of the predicate instead of nesting the predicate
    "!": NegativePredicate.new(inner:inner)
  }
  
  OrderedChoice << {
    # Build a right-associative tree if the first operand of another "/"
    "/": |other|
      private.binary_right_assoc(self, other, OrderedChoice)
  }
  
  Concatenation << {
    # Build a right-associative tree if the first operand of another "+"
    "+": |other=false|
      other
        &? private.binary_right_assoc(self, other, Concatenation)
        ?? OneOrMore.new(inner:self)
  }
  
  ##
  # Reduction and associated named captures implementation
  
  Reduction << {
    Environment < EmptyObject, BasicDecorators {
      var captures # A Hash of capture names to values
      var builder # The fallback delegate for methods that are not capture names
      
      method_missing: |name, *args, &block|
        captures.fetch(name) { builder.__send__(name, *args, &block) }
      
      # Implement the action for the reduction in the '!' method.
      # It will have access to the captures via method_missing.
      "!": null
    }
    
    code: block.block.compiled_code
  }
}
