
BytecodeMachine < BasicObject, BytecodeInstructions {
  var subject: ""
  var grammar: Grammar { }
  
  var g # TODO: remove and localize so that rules can be compiled in parallel
  
  compile_worker: {
    worker = EmptyObject { }
    grammar.construct_all_rules
    grammar.rule_table.each |name, rule| {
      compile_rule_into(worker, name, rule)
    }
    worker
  }
  
  compile_rule_into: |worker, name, rule| {
    construct = rule.construct_rule
    
    worker.component.dynamic_method(name, "(compiled parser)") |g| {
      self.g = g
      g.extend(BytecodeHelpers)
      
      g.rule_start
      construct.bytecode(self)
      g.rule_finish
    }
  }
  
  # Execute the root rule instruction sequence over the given subject
  execute: {
    worker = compile_worker
    # puts(worker.method(:root).executable.decode) # Print for debug
    worker.instance_variable_set(:"@captures", [])
    self.result = worker.root(subject, 0)
    self.captures = worker.instance_variable_get(:"@captures")
  }
  
  var result
  var captures
}
