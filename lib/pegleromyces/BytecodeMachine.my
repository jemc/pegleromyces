
BytecodeMachine < BasicObject {
  var subject: ""
  var grammar: Grammar { }
  
  new_worker: set_up_worker(prototype.new)
  
  var prototype: compile_prototype
  
  refresh: self.prototype = compile_prototype
  
  compile_prototype: {
    proto = Component.new
    grammar.construct_all_rules
    grammar.rule_table.each |name, rule| {
      compile_rule_into(proto, name, rule)
    }
    proto
  }
  
  compile_rule_into: |proto, name, rule| {
    construct = rule.construct_rule
    
    proto.dynamic_method(name, "(compiled parser)") |g| {
      instructor = BytecodeInstructions { }
      instructor.g = g
      g.extend(BytecodeHelpers)
      
      g.rule_start
      construct.bytecode(instructor)
      g.rule_finish
    }
  }
  
  set_up_worker: |worker|
    worker.instance_variable_set(:"@captures", []); worker
  
  captures_of_worker: |worker|
    worker.instance_variable_get(:"@captures")
  
  # Execute the root rule instruction sequence over the given subject
  execute: {
    worker = new_worker
    self.result = worker.root(subject, 0)
    self.captures = captures_of_worker(worker)
  }
  
  var result
  var captures
}
