
BasicSpec {
  name: "BytecodeParser"
  
  new_parser: BytecodeParser { }
  
  [tests]
  
  it "can match from a tiny grammar": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root:
        str('abc') / str('x') + set('Yy') + !str('y') + !!range('a','z') + any
    }
    parser.parse('xyz')
    assert_equal(parser.end_idx, 3)
  }
  
  it "can match from a grammar with multiplicit patterns": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root: str('x').+ + str('y').* + str('z').-
    }
    parser.parse('xxz')
    assert_equal(parser.end_idx, 3)
  }
  
  it "can match from a grammar with rule calls": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root: unintended / intended
      rule unintended: abc
      rule intended: x + any_y + not_y + any_lower
      
      rule abc:   str('abc')
      rule x:     str('x')
      rule any_y: set('Yy')
      rule not_y: !str('y')
      rule lower: range('a','z')
      rule any_lower: !!lower + any
    }
    parser.parse('xyz')
    assert_equal(parser.end_idx, 3)
  }
  
  it "can save a parser to a file to load and run it later": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root: (r(character.+[:clist]) { clist })[:root]
      rule character: r(any[:text]) { text.to_sym }
    }
    parser.parse('xyz')
    assert_equal(parser.result.fetch(:root), [:x, :y, :z])
    parser.save_prototype("/tmp/pegleromyces_output.my.rbc")
    
    parser = new_parser
    parser.load_prototype("/tmp/pegleromyces_output.my.rbc")
    parser.parse('xyz')
    assert_equal(parser.result.fetch(:root), [:x, :y, :z])
  }
  
  it "can match from the Myco grammar": {
    parser = new_parser
    
    # TODO: remove this hack for getting the processor methods
    builder = BasicObject {
      var ast: BasicObject {
        var delegate: Myco::ToolSet::Parser.new("",null,null)
        method_missing: |meth, loc, *args| {
          delegate.send(:"process_"meth"", loc.line, *args)
        }
      }
    }
    parser.component.declare_meme(:new_builder) { builder }
    
    # TODO: Move this to somewhere encapsulated and reasonable
    proto_file = "/tmp/pegleromyces_myco_prototype.my.rbc"
    grammar_file = ""Myco.cscope.myco_file.instance.dirname"/fixtures/MycoGrammar.my"
    unless (::File.exists?(proto_file) &&
            ::File.stat(proto_file).mtime >= ::File.stat(grammar_file).mtime) {
      parser.grammar = Myco.eval_file(grammar_file, [], true, Myco.cscope)
      parser.save_prototype(proto_file)
    }
    parser.load_prototype(proto_file)
    
    examples = [
      'Object {
        foo: one
      }'
      [:declobj, [:array, [:const, :"Object"]], [:block, 
        [:meme, :foo, [:array], [:args, :"*"], [:block, [:lambig, :one]]],
      ]]
    ]
    
    examples.each_slice(2) |input, output| {
      parser.parse(input)
      result = parser.result.fetch(:root)
      result = result.body.to_sexp.last
      assert_equal(result, output)
    }
  }
}
