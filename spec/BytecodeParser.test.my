
BasicSpec {
  name: "BytecodeParser"
  
  new_parser: BytecodeParser { }
  
  [tests]
  
  it "can match from a tiny grammar": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root:
        str('abc') / str('x') + set('Yy') + !str('y') + !!range('a','z') + any
    }
    parser.parse('xyz')
    assert_equal(parser.end_idx, 3)
  }
  
  it "can match from a grammar with multiplicit patterns": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root: str('x').+ + str('y').* + str('z').-
    }
    parser.parse('xxz')
    assert_equal(parser.end_idx, 3)
  }
  
  it "can match from a grammar with rule calls": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root: unintended / intended
      rule unintended: abc
      rule intended: x + any_y + not_y + any_lower
      
      rule abc:   str('abc')
      rule x:     str('x')
      rule any_y: set('Yy')
      rule not_y: !str('y')
      rule lower: range('a','z')
      rule any_lower: !!lower + any
    }
    parser.parse('xyz')
    assert_equal(parser.end_idx, 3)
  }
  
  it "skips memoized rule calls without result corruption": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root: moot
      rule moot:
        (array[:root] + str('NO')) / (array[:root] + str('NOPE')) / array[:root]
      rule array:
        r(str('[').token(:foo)[:t0] + (!str(']') + any).*[:list] + str(']'))
          { [:array, t0.line, *list.map(&:to_sym)] }
    }
    parser.parse('[abc]')
    assert(parser.end_idx)
    assert_equal(parser.result[:root], [:array, 1, :a, :b, :c])
  }
  
  it "can save a parser to a file to load and run it later": {
    parser = new_parser
    parser.grammar = Grammar {
      [rules]
      rule root: (r(character.+[:clist]) { clist })[:root]
      rule character: r(any[:text]) { text.to_sym }
    }
    parser.parse('xyz')
    assert_equal(parser.result.fetch(:root), [:x, :y, :z])
    parser.save_prototype("/tmp/pegleromyces_output.my.rbc")
    
    parser = new_parser
    parser.load_prototype("/tmp/pegleromyces_output.my.rbc")
    parser.parse('xyz')
    assert_equal(parser.result.fetch(:root), [:x, :y, :z])
  }
  
  it "can match from the Myco grammar": {
    parser = new_parser
    
    # TODO: remove this hack for getting the processor methods
    builder = BasicObject {
      var ast
      
      var escape_encodings: {
        hash = Hash.new
        hash["\\a"] = "\a" # \a  0x07  Bell or alert
        hash["\\b"] = "\b" # \b  0x08  Backspace
        # TODO:            # \cx       Control-x
        # TODO:            # \C-x      Control-x
        hash["\\e"] = "\e" # \e  0x1b  Escape
        hash["\\f"] = "\f" # \f  0x0c  Formfeed
        # TODO:            # \M-\C-x   Meta-Control-x
        hash["\\n"] = "\n" # \n  0x0a  Newline
        # TODO:            # \nnn      Octal notation, where n is a digit
        hash["\\r"] = "\r" # \r  0x0d  Carriage return
        hash["\\s"] = "\s" # \s  0x20  Space
        hash["\\t"] = "\t" # \t  0x09  Tab
        hash["\\v"] = "\v" # \v  0x0b  Vertical tab
        # TODO:            # \xnn      Hexadecimal notation, where n is a digit
        hash
      }
      
      # Encode escape characters in string literals
      # TODO: rigorously test and refine
      encode_escapes: |str| {
        str.gsub(Regexp.new("\\.")) |substr| {
          escape_encodings.fetch(substr, substr[-1])
        }
      }
      
      # Given a node,op list ([node, op, node, op, ... node]) and operator types,
      # collapse the (node, op, node) groups where the operator is one of the types
      #
      # This function is meant to be called several times on the same list,
      # with a different set of operator types each time, in order of precedence.
      #
      collapse: |input, *types, &block| {
        output = []
        
        # Scan through, reducing or shifting based on the operator
        loop {
          (input.count > 2) || break
          n0 = input.shift
          op = input.shift
          
          types.include?(op.type) &? (
            n1 = input.shift
            
            result = block
              &? block.call(n0,op,n1)
              ?? ast.invoke(op, n0, op.sym, ast.argass(n1, [n1]))
            input.unshift(result)
          ) ?? (
            output.push(n0)
            output.push(op)
          )
        }
        
        # Push the last item remaining
        output.push(input.shift)
        
        input.replace(output)
      }
    }
    builder.ast = Myco::ToolSet::AST::Builder.new
    parser.component.declare_meme(:new_builder) { builder }
    
    # TODO: Move this to somewhere encapsulated and reasonable
    proto_file = "/tmp/pegleromyces_myco_prototype.my.rbc"
    grammar_file = ""Myco.cscope.myco_file.instance.dirname"/fixtures/MycoGrammar.my"
    unless (::File.exists?(proto_file) &&
            ::File.stat(proto_file).mtime >= ::File.stat(grammar_file).mtime) {
      parser.grammar = Myco.eval_file(grammar_file, [], true, Myco.cscope)
      parser.save_prototype(proto_file)
    }
    parser.load_prototype(proto_file)
    
    examples = [
      'Object {
        foo: one
      }'
      [:declobj, [:array, [:const, :"Object"]], [:block, 
        [:meme, :foo, [:array], [:args, :"*"], [:block, [:lambig, :one]]],
      ]]
    ]
    
    examples.each_slice(2) |input, output| {
      parser.parse(input)
      result = parser.result
      result &? (
        result = result.fetch(:root).body.to_sexp.last
        assert_equal(result, output)
      ) ?? parser.raise_error
    }
  }
}
