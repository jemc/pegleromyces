
BasicSpec {
  name: "Parser"
  
  new_parser: Parser { }
  
  basic_grammar: Grammar {
    c: character_classes
    
    [character_classes]
    upper: range('A','Z')
    lower: range('a','z') / str('_')
    num:   range('0','9')
    alpha: upper / lower
    spc:   set(" \t\r\f\v")
    
    [rules]
    rule root: expr[:root]
    rule expr: (array / assign / constant / ident / float / integer)
    
    rule sepd_expr: r(c.spc.* + str(',') + c.spc.* + integer[:n0]) { n0 }
    rule array: r(str('[') + expr[:n0] + sepd_expr.*[:nrest] + str(']'))
                  { [n0, *nrest] }
    
    rule constant: r((c.upper + c.alpha.*)[:text])  { [:constant, text.to_sym] }
    rule ident:    r((c.lower + c.alpha.*)[:text])  { [:ident,    text.to_sym] }
    rule integer:  r((str('-').- + c.num.+)[:text]) { [:integer,  text.to_i] }
    rule float:    r((str('-').- + c.num.+ + str('.') + c.num.+)[:text])
                                                    { [:float,    text.to_f] }
    
    rule assign_lhs: (constant / ident)
    rule assign_rhs: expr
    rule assign: r(assign_lhs[:lhs] + c.spc.* + str('=') + c.spc.* +
                   assign_rhs[:rhs]) { [:assign, lhs, rhs] }
  }
  
  [tests]
  
  it "starts with a grammar that matches any string": {
    assert(new_parser.parse("xyz").result)
  }
  
  it "can parse from a basic grammar": {
    parser = new_parser
    parser.grammar = basic_grammar
    
    examples = [
      "xyz",           [:ident, :xyz]
      "_foo = -88.8",  [:assign, [:ident, :"_foo"], [:float, -88.8]]
      "Foo_BAR=5",     [:assign, [:constant, :"Foo_BAR"], [:integer, 5]]
      "[99, 99]",      [[:integer, 99], [:integer, 99]]
    ]
    
    examples.each_slice(2) |input, output| {
      assert_equal(parser.parse(input).result.fetch(:root), output)
    }
  }
}
