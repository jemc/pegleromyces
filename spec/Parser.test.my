
BasicSpec {
  name: "Parser"
  
  new_parser: Parser { }
  g: Patterns::ShorthandMethods { }
  
  [tests]
  
  it "starts with a grammar that matches any string": {
    assert(new_parser.parse("xyz").result)
  }
  
  it "stores the resulting toplevel captures in results": {
    parser = new_parser
    parser.grammar = g.r(g.any.*[:foo]) { "ABC_"foo"_123" }
    parser.grammar = (parser.grammar)[:root]
    
    parser.parse("xyz")
    assert_equal(parser.result.fetch(:root), "ABC_xyz_123")
  }
  
  it "can parse from a basic nested grammar": {
    
    c_upper  = g.range('A','Z')
    c_lower  = g.range('a','z') / g.str('_')
    c_num    = g.range('0','9')
    c_alpha  = c_upper / c_lower
    
    c_nl     = g.str("\n")
    c_eof    = !g.any
    c_eol    = c_nl / c_eof
    
    comment  = g.str('#') + (!c_eol + g.any).*
    c_spc    = g.set(" \t\r\f\v") / g.str("\\\n") / comment
    c_spc_nl = c_spc / c_nl
    
    constant = g.r((c_upper + c_alpha.*)[:text]) { [:constant, text.to_sym] }
    ident    = g.r((c_lower + c_alpha.*)[:text]) { [:ident,    text.to_sym] }
    integer  = g.r((g.str('-').- + c_num.+)[:text])
                                                 { [:integer,  text.to_i] }
    float    = g.r((g.str('-').- + c_num.+ + g.str('.') + c_num.+)[:text])
                                                 { [:float,    text.to_f] }
    
    assign_lhs = (constant / ident)
    assign_rhs = (constant / ident / float / integer)
    assign = g.r(assign_lhs[:lhs] + c_spc.*
                 + g.str('=') + c_spc.*
                 + assign_rhs[:rhs])
               { [:assign, lhs, rhs] }
    
    expr = (assign / constant / ident / float / integer)
    root = expr
    
    examples = [
      "xyz",           [:ident, :xyz]
      "99",            [:integer, 99]
      "_foo = -88.8",  [:assign, [:ident, :"_foo"], [:float, -88.8]]
      "Foo_BAR = 5",   [:assign, [:constant, :"Foo_BAR"], [:integer, 5]]
    ]
    
    examples.each_slice(2) |input, output| {
      parser = new_parser
      parser.grammar = root[:root]
      
      assert_equal(parser.parse(input).result.fetch(:root), output)
    }
  }
}
