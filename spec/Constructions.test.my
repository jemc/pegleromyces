
BasicSpec {
  name: "Constructions"
  
  [tests]
  
  specify "AnyCharacter creates a single any instruction": {
    construct = Constructions::AnyCharacter.new
    assert_equal(construct.sequence, [
      [:any, 1]
    ])
  }
  
  specify "Character creates a single char instruction": {
    construct = Constructions::Character.new(code:120)
    assert_equal(construct.sequence, [
      [:char, 120]
    ])
  }
  
  specify "CharacterString creates a string of char instructions": {
    construct = Constructions::CharacterString.new(codes:[120,121,122])
    assert_equal(construct.sequence, [
      [:char, 120]
      [:char, 121]
      [:char, 122]
    ])
  }
  
  specify "CharacterSet creates a single charset instruction": {
    construct = Constructions::CharacterSet.new(codes:[120,121,122])
    expected_table = [120,121,122].map |code| { [code,true] }.to_h
    assert_equal(construct.sequence, [
      [:charset, expected_table]
    ])
  }
  
  specify "CharacterRange creates a single charrange instruction": {
    construct = Constructions::CharacterRange.new(start:120, end:122)
    assert_equal(construct.sequence, [
      [:charrange, 120, 122]
    ])
  }
  
  specify "NegativePredicate assembles choice, fail_twice instructions": {
    a = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::NegativePredicate.new(inner:a)
    assert_equal(construct.sequence, [
      [:choice, 5] # ip+5 == L1
      [:char, 120]
      [:char, 121]
      [:char, 122]
      [:fail_twice]
    ])             # (L1)
  }
  
  specify "PositivePredicate assembles choice, commit, fail instructions": {
    a = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::PositivePredicate.new(inner:a)
    assert_equal(construct.sequence, [
      [:choice, 7] # ip+7 == L1
      [:choice, 4] # ip+4 == L2
      [:char, 120]
      [:char, 121]
      [:char, 122]
      [:commit, 1] # ip+1 == L3 (L2)
      [:fail]      # (L3)
    ])             # (L1)
  }
  
  specify "OneOrMore assembles UNOPTIMIZED instructions": {
    a = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::OneOrMore.new(inner:a)
    assert_equal(construct.sequence, [
      [:char, 120] # TODO: optimize and eliminate the double specification here
      [:char, 121]
      [:char, 122]
      [:choice, 5] # ip+5 == L2
      [:char, 120] # (L1)
      [:char, 121]
      [:char, 122]
      [:partial_commit, -3] # ip-3 == L1
    ])             # (L2)
  }
  
  specify "ZeroOrOne assembles choice and commit instructions": {
    a = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::ZeroOrOne.new(inner:a)
    assert_equal(construct.sequence, [
      [:choice, 5] # ip+5 == L1
      [:char, 120]
      [:char, 121]
      [:char, 122]
      [:commit, 1] # ip+1 == L1
    ])             # (L1)
  }
  
  specify "ZeroOrMore assembles choice and partial_commit instructions": {
    a = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::ZeroOrMore.new(inner:a)
    assert_equal(construct.sequence, [
      [:choice, 5] # ip+5 == L2
      [:char, 120] # (L1)
      [:char, 121]
      [:char, 122]
      [:partial_commit, -3] # ip-3 == L1
    ])             # (L2)
  }
  
  specify "ZeroOrMore<CharacterSet> creates a single span instruction": {
    a = Constructions::CharacterSet.new(codes:[120,121,122])
    construct = Constructions::ZeroOrMore.new(inner:a)
    expected_table = [120,121,122].map |code| { [code,true] }.to_h
    assert_equal(construct.sequence, [
      [:span, expected_table]
    ])
  }
  
  specify "OrderedChoice assembles choice and commit instructions": {
    a = Constructions::CharacterString.new(codes:[110,111,112])
    b = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::OrderedChoice.new(first:a, second:b)
    assert_equal(construct.sequence, [
      [:choice, 5] # ip+5 == L1
      [:char, 110]
      [:char, 111]
      [:char, 112]
      [:commit, 4] # ip+4 == L2
      [:char, 120] # (L1)
      [:char, 121]
      [:char, 122]
    ])             # (L2)
    
    a = Constructions::CharacterString.new(codes:[110,111,112])
    b = Constructions::CharacterString.new(codes:[120,121,122])
    c = Constructions::CharacterString.new(codes:[130,131,132])
    construct = Constructions::OrderedChoice.new(first:b, second:c)
    construct = Constructions::OrderedChoice.new(first:a, second:construct)
    assert_equal(construct.sequence, [
      [:choice, 5] # ip+5 == L1
      [:char, 110]
      [:char, 111]
      [:char, 112]
      [:commit, 9] # ip+9 == L2
      [:choice, 5] # ip+5 == L3; (L1)
      [:char, 120]
      [:char, 121]
      [:char, 122]
      [:commit, 4] # ip+4 == L2
      [:char, 130] # (L3)
      [:char, 131]
      [:char, 132]
    ])             # (L2)
  }
  
  specify "Concatenation simply concatenates the operands": {
    a = Constructions::CharacterString.new(codes:[110,111,112])
    b = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::Concatenation.new(first:a, second:b)
    assert_equal(construct.sequence, [
      [:char, 110]
      [:char, 111]
      [:char, 112]
      [:char, 120]
      [:char, 121]
      [:char, 122]
    ])
  }
  
  specify "NamedCapture assembles capture instructions": {
    a = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::NamedCapture.new(inner:a)
    assert_equal(construct.sequence, [
      [:capture, [:start, construct.captor]]
      [:char, 120]
      [:char, 121]
      [:char, 122]
      [:capture, [:end, construct.captor]]
    ])
  }
  
  specify "Reduction assembles capture instructions": {
    a = Constructions::CharacterString.new(codes:[120,121,122])
    construct = Constructions::Reduction.new(inner:a)
    assert_equal(construct.sequence, [
      [:capture, [:r_start, construct.captor]]
      [:char, 120]
      [:char, 121]
      [:char, 122]
      [:capture, [:r_end, construct.captor]]
    ])
  }
}
